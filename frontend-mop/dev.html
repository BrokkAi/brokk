<!DOCTYPE html>
<html class="theme-light">
<head>
  <meta charset="utf-8">
  <title>Brokk MOP - Dev Mode</title>
</head>
<style>
  #mop-root {
    top: 210px !important;
  }
  #dev-tools {
    margin: 1em;
  }
</style>
<body>
<div id="dev-tools">
  <h1>Brokk MOP - Development Mode</h1>
  <p>Events from Java will be logged to the console and displayed raw below.</p>
  <h3>Dev Tools</h3>
  <button onclick="streamAsk()">Stream "Ask"</button>
  <button onclick="streamEdit()">Stream "Edit"</button>
  <button onclick="showMd()">Show MD</button>
  <button onclick="window.brokk.setTheme(!document.querySelector('html').classList.contains('theme-dark'))">Toggle Theme</button>
  <button onclick="window.brokk.clear()">Clear Log</button>
  <button onclick="window.brokk.showSpinner('Testing spinner...'); setTimeout(() => window.brokk.hideSpinner(), 2000);">
    Test Spinner
  </button>
  <button onclick="window.brokk.hideSpinner()">Hide Spinner</button>
</div>
<script type="module" src="/src/index.ts"></script>
<script>
  // Immediately define brokk with a buffer to catch early events and calls from Java
  (function() {
    const buffer = []; // Unified buffer for all calls and events
    let seq = 0; // Sequence number to maintain order

    window.brokk = new Proxy({
      _buffer: buffer
    }, {
      get(target, prop) {
        if (prop === '_buffer') {
          return target[prop];
        }
        return (...args) => {
          if (prop === 'onEvent') {
            console.log('Buffering early event from Java:', JSON.stringify(args));
            buffer.push({ type: 'event', payload: args[0], seq: seq++ });
          } else if (prop === 'hideSpinner') {
            console.log('Buffering early call from Java to', prop);
            buffer.push({ type: 'call', method: prop, args: [], seq: seq++ });
          } else {
            console.log('Buffering early call from Java to', prop);
            buffer.push({ type: 'call', method: prop, args: args, seq: seq++ });
          }
          return undefined;
        };
      }
    });
  })();
  // Mock Java bridge for dev mode
  window.javaBridge = {
    onAck: (epoch) => console.log('Mock ACK for epoch:', epoch)
  };

  function simulateEvent(type, data = {}) {
    window.brokk.onEvent({type, epoch: Date.now(), ...data});
  }


    const contentUser = `> "npm run dev" should run vite/svelte based on dev.html? \nany idea?`;
    const contentAi = `
### Why Vite is showing *index.html* even though you have *dev.html*

1. **Vite’s default entry point**
   When you execute \`vite\` (or \`vite --port 5173\`) the dev-server looks in the project root for \`index.html\`.
   Any other HTML files (e.g. \`dev.html\`) are still reachable at \`http://localhost:5173/dev.html\`, but the page that Vite *automatically* opens in the browser (or shows when you visit the bare root \`/\`) is always \`index.html\` unless you change either:
   - the **root directory**, or
   - the **page that the browser is told to open**.

  \`\`\`java
  @Tool("Create a GitHub pull-request for the current branch. "
          + "If title or body is blank they are auto-generated. "
          + "This implicitly pushes the branch and sets upstream when needed.")
    public String createPullRequest(
            @Nullable @P("PR title (optional)")  String title,
    @Nullable @P("PR description in Markdown (optional)") String body)
    {
      var cursor = messageCursor();
      io.llmOutput("Creating pull request…", ChatMessageType.CUSTOM, true);

      try {
        var project = contextManager.getProject();
        if (!project.hasGit())
          throw new IllegalStateException("Not a Git repository");

        var repo          = (GitRepo) project.getRepo();
        var defaultBranch = repo.getDefaultBranch()
                .orElseThrow(() -> new IllegalStateException("Cannot determine default branch"));
        var currentBranch = repo.getCurrentBranch();
        if (Objects.equals(currentBranch, defaultBranch))
          throw new IllegalStateException("Refusing to open PR from default branch (" + defaultBranch + ')');

        if (!repo.getModifiedFiles().isEmpty())
          throw new IllegalStateException("Uncommitted changes present; commit first");

        var gws = new GitWorkflowService(contextManager);

        // Auto-generate title/body if blank
        if (title == null || title.isBlank() || body == null || body.isBlank()) {
          var suggestion = gws.suggestPullRequestDetails(currentBranch, defaultBranch);
          if (title == null || title.isBlank()) title = suggestion.title();
          if (body  == null || body.isBlank())  body  = suggestion.description();
        }

        var prUrl = gws.createPullRequest(currentBranch, defaultBranch, title.trim(), body.trim());
        var msg   = "Opened PR: " + prUrl;
        io.llmOutput(msg, ChatMessageType.CUSTOM);
        logger.info(msg);

        // Persist result to history
        var newMessages = messagesSince(cursor);
        contextManager.addToHistory(new TaskResult(contextManager,
                        "Git create PR",
                        newMessages,
                        Set.of(),
                        TaskResult.StopReason.SUCCESS),
                false);
        return msg;
      } catch (Exception e) {
      var err = "Create PR failed: " + e.getMessage();
      io.llmOutput(err, ChatMessageType.CUSTOM);
      logger.error(err, e);

      var newMessages = messagesSince(cursor);
      contextManager.addToHistory(new TaskResult(contextManager,
                      "Git create PR",
                      newMessages,
                      Set.of(),
                      TaskResult.StopReason.TOOL_ERROR),
              false);
      throw new RuntimeException(err, e);
    }
    }
  \`\`\`

2. **Where your files live**
   Your tree is:

   \`\`\`
   frontend-mop/
     dev.html          ← dev-only page
     index.html        ← production entry
     vite.config.mjs
     src/
   \`\`\`

   That means:
   - Production build (\`vite build\`) will read *index.html* (because that is Vite convention when \`root\` is the repo root).
   - Dev server (\`vite\`) will also treat *index.html* as the “home page”, while *dev.html* is reachable as a secondary route.

---

### Options to make \`npm run dev\` “start with” \`dev.html\`

| Option | What you change | Pros | Cons |
|--------|-----------------|------|------|
| 1. Add a query to the \`open\` option | vite.config.mjs<br>\`server: { open: '/dev.html' }\` | Zero CLI changes; auto-opens correct page | Still serves \`index.html\` at \`/\`; not ideal if you *never* want \`index.html\` in dev |
| 2. Modify the npm script | \`"dev": "vite --open /dev.html"\` | No config file edits | Same caveat as above |
| 3. Point the dev server at a different **root** | Create \`frontend-mop/dev/\` and move/rename files so *dev.html* becomes \`dev/index.html\` and set \`root: 'dev'\` just for the dev command (e.g. with a second Vite config) | Clean separation of dev vs prod HTML | Requires file moves or a second config file |
| 4. Symlink or rename | Temporarily rename \`dev.html\` → \`index.html\` when in dev (via a pre-dev script) | Works with zero Vite tweaks | Adds build-step complexity / brittle |

### Minimal, lowest-friction fix

Add a small dev-only section to \`vite.config.mjs\`:

\`\`\`js
import { defineConfig } from 'vite'
import { svelte } from '@sveltejs/vite-plugin-svelte'

export default defineConfig(({ command }) => ({
  plugins: [svelte()],
  build: {
    outDir: '../src/main/resources/mop-web',
    emptyOutDir: true
  },
  // Only for \`vite dev\`
  server: {
    port: 5173,
    // Open /dev.html instead of /
    open: command === 'serve' ? '/dev.html' : undefined
  }
}))
\`\`\`

Or if you prefer not to touch \`vite.config.mjs\`, simply update the npm script:

\`\`\`json
"scripts": {
  "dev": "vite --port 5173 --open /dev.html",
  ...
}
\`\`\`

Both approaches:

1. Keep production build logic intact (still builds from \`index.html\`).
2. Automatically open \`http://localhost:5173/dev.html\` whenever you run \`npm run dev\`.
3. Still allow visiting \`index.html\` by typing the full URL if ever needed.

### Key takeaway

- Vite always *serves* every HTML file under \`root\`, but it *opens* only one page at start-up.
- Adjusting \`server.open\` (or the CLI \`--open\`) lets you point dev mode to whichever HTML file you want without disturbing the production build.
`;
 function streamAsk() {
    let index = 0;
    simulateEvent('chunk', {text: contentUser, msgType: 'USER', streaming: true})
    const chunks = contentAi.match(/[\s\S]{1,10}/g) || [];
    const interval = setInterval(() => {
      if (index < chunks.length) {
        simulateEvent('chunk', {text: chunks[index], msgType: 'AI', streaming: true});
        index++;
      } else {
        clearInterval(interval);
      }
    }, 10);
  }

  function showMd() {
      simulateEvent('chunk', {text: contentUser, msgType: 'USER', streaming: false})
      simulateEvent('chunk', {text: contentAi, msgType: 'AI', streaming: false})
      simulateEvent('chunk', {text: "# Now we are finished!", msgType: 'CUSTOM', streaming: false})
  }

  function streamEdit() {
    const contentUser = `fix it`;
    const contentAi = `I understand the issue with the ordering of buffered events and calls in the JavaScript code, which causes the UI to sometimes clear at the end due to incorrect replay order. The problem stems from having two separate buffers (\`_callQueue\` and \`_eventBuffer\`) and replaying them in the wrong order. I'll fix this by unifying the buffer into a single queue with a sequence number to maintain the correct order of operations during replay.

Here's the plan:
1. Modify the temporary stub in \`index.html\` to use a single buffer with a sequence number.
2. Update the replay logic in \`index.ts\` to process this unified buffer in sequence order.

Here are the *SEARCH/REPLACE* blocks to implement these changes:

\`\`\`
frontend-mop/index.html
<<<<<<< SEARCH
    // Immediately define brokk with a proxy to buffer all early calls from Java
    (function() {
      const callQueue = []; // Stores {method, args} for all calls except onEvent
      const eventBuffer = []; // Stores payloads for onEvent

      window.brokk = new Proxy({
        _callQueue: callQueue,
        _eventBuffer: eventBuffer
      }, {
        get(target, prop) {
          // Allow direct access to internal queues
          if (prop === '_callQueue' || prop === '_eventBuffer') {
            return target[prop];
          }
          // Return a stub function for any other property access
          return (...args) => {
            if (prop === 'onEvent') {
              console.log('Buffering early event from Java:', JSON.stringify(args));
              eventBuffer.push(...args);
            } else {
              console.log('Buffering early call from Java to', prop);
              callQueue.push({ method: prop, args });
            }
            // Provide default return values for synchronous methods
            if (prop === 'getSelection') {
              return '';
            }
            return undefined;
          };
        }
      });
    })();
=======
    // Immediately define brokk with a proxy to buffer all early calls from Java
    (function() {
      const buffer = []; // Unified buffer for all calls and events
      let seq = 0; // Sequence number to maintain order

      window.brokk = new Proxy({
        _buffer: buffer
      }, {
        get(target, prop) {
          // Allow direct access to internal buffer
          if (prop === '_buffer') {
            return target[prop];
          }
          // Return a stub function for any other property access
          return (...args) => {
            if (prop === 'onEvent') {
              console.log('Buffering early event from Java:', JSON.stringify(args));
              buffer.push({ type: 'event', payload: args[0], seq: seq++ });
            } else {
              console.log('Buffering early call from Java to', prop);
              buffer.push({ type: 'call', method: prop, args: args, seq: seq++ });
            }
            // Provide default return values for synchronous methods
            if (prop === 'getSelection') {
              return '';
            }
            return undefined;
          };
        }
      });
    })();
>>>>>>> REPLACE
\`\`\`

\`\`\`
frontend-mop/src/index.ts
<<<<<<< SEARCH
// Retrieve buffered calls and events from the early stub
const pendingCalls = window.brokk._callQueue || [];
const bufferedEvents = window.brokk._eventBuffer || [];

// Replace the temporary brokk proxy with the real implementation
window.brokk = {
  _callQueue: [],
  _eventBuffer: [],
  onEvent: (payload) => {
    console.log('Received event from Java bridge:', JSON.stringify(payload));
    eventStore.set(payload);

    // ACK after a frame render to ensure UI has updated
    if (payload.epoch) {
      requestAnimationFrame(() => {
        if (window.javaBridge) {
          window.javaBridge.onAck(payload.epoch);
        }
      });
    }
  },
  getSelection: () => {
    return window.getSelection()?.toString() ?? '';
  },
  clear: () => {
    eventStore.set({ type: 'chunk', text: '', isNew: true, msgType: 'SYSTEM', epoch: 0 });
  },
  setTheme: (dark) => {
    themeStore.set(dark);
    if (dark) {
      document.body.classList.add('theme-dark');
    } else {
      document.body.classList.remove('theme-dark');
    }
  },
  showSpinner: (message) => {
    spinnerStore.set(message);
  }
};

// Process any buffered events first to maintain temporal order
if (bufferedEvents.length > 0) {
  console.log('Replaying', bufferedEvents.length, 'buffered events');
  bufferedEvents.forEach(event => {
    window.brokk.onEvent(event);
  });
}

// Then replay any other buffered method calls
if (pendingCalls.length > 0) {
  console.log('Replaying', pendingCalls.length, 'buffered method calls');
  pendingCalls.forEach(({ method, args }) => {
    console.log('Replaying call to', method, 'with args:', args);
    const brokk = window.brokk as Record<string, (...args: unknown[]) => unknown>;
    if (typeof brokk[method] === 'function') {
      brokk[method](...args);
    } else {
      console.warn('Method', method, 'no longer exists; skipping replay');
    }
  });
}
=======
// Retrieve buffered calls and events from the early stub
const buffer = window.brokk._buffer || [];

// Replace the temporary brokk proxy with the real implementation
window.brokk = {
  _buffer: [],
  onEvent: (payload) => {
    console.log('Received event from Java bridge:', JSON.stringify(payload));
    eventStore.set(payload);

    // ACK after a frame render to ensure UI has updated
    if (payload.epoch) {
      requestAnimationFrame(() => {
        if (window.javaBridge) {
          window.javaBridge.onAck(payload.epoch);
        }
      });
    }
  },
  getSelection: () => {
    return window.getSelection()?.toString() ?? '';
  },
  clear: () => {
    eventStore.set({ type: 'chunk', text: '', isNew: true, msgType: 'SYSTEM', epoch: 0 });
  },
  setTheme: (dark) => {
    themeStore.set(dark);
    if (dark) {
      document.body.classList.add('theme-dark');
    } else {
      document.body.classList.remove('theme-dark');
    }
  },
  showSpinner: (message) => {
    spinnerStore.set(message);
  }
};

// Replay buffered calls and events in sequence order
if (buffer.length > 0) {
  console.log('Replaying', buffer.length, 'buffered items');
  buffer.sort((a, b) => a.seq - b.seq).forEach(item => {
    if (item.type === 'event') {
      console.log('Replaying event with epoch:', item.payload.epoch);
      window.brokk.onEvent(item.payload);
    } else {
      console.log('Replaying call to', item.method, 'with args:', item.args);
      const brokk = window.brokk as Record<string, (...args: unknown[]) => unknown>;
      if (typeof brokk[item.method] === 'function') {
        brokk[item.method](...item.args);
      } else {
        console.warn('Method', item.method, 'no longer exists; skipping replay');
      }
    }
  });
}
>>>>>>> REPLACE
\`\`\`
    `;
    let index = 0;
    simulateEvent('clear');
    simulateEvent('chunk', {text: contentUser, msgType: 'USER', streaming: true});
    const chunks = contentAi.match(/[\s\S]{1,10}/g) || [];
    const interval = setInterval(() => {
      if (index < chunks.length) {
        simulateEvent('chunk', {text: chunks[index], msgType: 'AI', streaming: true});
        index++;
      } else {
        clearInterval(interval);
      }
    }, 10);
  }
</script>
<div id="mop-root"></div>
</body>
</html>
