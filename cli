# brokkctl — CLI Controller Specification (Spike)

This document specifies a small, focused CLI controller — working name `brokkctl` — that discovers and talks to running Brokk desktop processes and presents a machine-friendly, JSON-first automation surface. This is a specification-only spike: it defines the surface, semantics, and versioning rules needed to implement a CLI controller and compatible MCP/REST/AppleScript endpoints. It does not prescribe implementation details or require changes to Brokk internals.

## Overview

`brokkctl` is an orchestration layer intended for automation and scripting. Its responsibilities are:

- Discover local Brokk instances that expose a control endpoint.
- Send commands to one or more instances and aggregate responses.
- Provide a stable, machine-readable JSON API for automation; human-friendly output is optional.
- Negotiate capabilities and compatibility via a lightweight protocol version.

This spec is implementation-agnostic: discovery can be implemented by registry, socket probing, mDNS, or another platform-appropriate mechanism. The important part is the semantics and compatibility guarantees offered to clients.

## Goals

- Define a stable, machine-friendly CLI surface for common automation tasks:
  - Instance discovery and selection
  - Project open/list/get actions
  - Session create/list/get/import/export
  - Context manipulation (add files/classes/methods/text)
  - Querying session output / history
  - Execution control: submit/stream/cancel jobs (ASK, SEARCH, CODE, ARCHITECT, LUTZ)
- Make JSON the canonical output mode (`-o json`), with NDJSON for streaming event feeds.
- Support multi-instance fan-out with well-defined per-instance and aggregate results.
- Provide a versioned protocol and compatibility policy enabling graceful client and server evolution.
- Produce a concise, testable spec to guide implementations in the application and a standalone `brokkctl` tool.

## Non-goals

- This is a spec-only spike. It does not modify application core logic, private storage formats, or internal behavior.
- The spec does not mandate a discovery transport (mDNS vs sockets vs registry). Implementers choose platform-appropriate mechanisms.
- This document does not provide exhaustive CLI UX text (help output). Those are implementation details.
- No runtime behavioral changes to the Brokk desktop application are required by this spec.

## Terminology

- instance  
  A running Brokk process that exposes a local control endpoint (MCP/HTTP/stdio). An instance is identified by an `instanceId` and a discovery descriptor (listen address, PID when available, socket path, etc.).

- project  
  The code workspace currently open in an instance. This is typically a repository root or workspace folder.

- session  
  A Brokk session (user session) representing a workspace snapshot, context, configuration, and transcript/history. Sessions are created, imported, exported, and selected inside an instance.

- context  
  Additional data seeded into a session to influence LLM reasoning: files, class summaries, method sources, or free-form text fragments. Context entries are addressable (IDs) and may be session- or job-scoped.

- history  
  The session transcript and action history: sequence of task entries, LLM outputs, notifications, diffs, and related metadata. Useful for resuming work or exporting results.

- execution (job)  
  A unit of work submitted to an instance for processing. Executions have modes (ASK, SEARCH, CODE, ARCHITECT, LUTZ), accept a `JobSpec` (sessionId, taskInput, models, flags), produce streamable events, and end with a `JobStatus` and optional diff.

## CLI Command Surface (conceptual)

Top-level command: `brokkctl`

Global flags:
- `--format json|text` — output format; `json` is the canonical machine-friendly default. `text` yields human-oriented pretty output.
- `--instance <selector>` — target a specific instance. Supported selector forms: instanceId (UUID), `pid:<n>`, `addr:<host:port>`, `socket:<path>`.
- `--all` — target all non-stale instances (fan-out).
- `--timeout <ms>` — overall timeout in milliseconds for discovery and per-request network operations (default: 30000).
- `--fail-fast` / `--best-effort` — fan-out failure policy. `--fail-fast` aborts on first failure (default); `--best-effort` attempts all targets and returns an aggregated result (partial success possible).
- `--protocol-version <MAJOR.MINOR.PATCH>` — advertise a specific client protocol version via the `Brokk-CTL-Version` header; if omitted the client will use its built-in version.
- `--auth-token <token>` — send `Authorization: Bearer <token>` to secured endpoints.
- `--allow-incompatible` — explicitly allow proceeding when client MAJOR > server MAJOR (dangerous; requires opt-in).

Example subcommands (conceptual):
- `brokkctl instances list` — list discovered instances
- `brokkctl project open --path <path>` — open a project in an instance
- `brokkctl sessions create --name <name>` — create a session
- `brokkctl sessions import --file <session.zip>` — import a session zip
- `brokkctl context add-file --path <relPath>` — add files to session context
- `brokkctl execution submit --session <id> --mode <MODE> --planner-model <model> --task "..."` — submit a job
- `brokkctl execution events --job <jobId> --follow` — stream job events (NDJSON)
- `brokkctl execution cancel --job <jobId>` — cancel job
- `brokkctl history get --session <id> --limit N` — fetch session history

All commands must support `-o json` and return structured JSON for automation. Streaming endpoints should use NDJSON or SSE with an option to pass through raw server stream.

## Discovery & Multi-instance Handling

Discovery semantics:
- `brokkctl` must discover zero or more instances and return descriptors with:
  - `instanceId` (string)
  - `pid` (optional)
  - `listenAddr` (host:port or socket path)
  - `project` (if available)
  - `brokkctlVersion` (protocol version the instance speaks)
  - `lastSeenMs` (timestamp hint for stability)

Registry location
- The instance registry is per-user and uses the platform's conventional user config directory. Implementations SHOULD store instance records as individual files in a directory to avoid write-contention and to allow atomic add/remove. Recommended locations:
  - Linux: `$XDG_CONFIG_HOME/brokk/instances/` (fallback: `$HOME/.config/brokk/instances/`)
  - macOS: `~/Library/Application Support/Brokk/instances/`
  - Windows: `%APPDATA%\Brokk\instances\`
- Each instance writes a single file named `<instanceId>.json` into the registry directory. Files MUST be written atomically (write temporary file then rename) to avoid partial reads.

Record schema
- Each `<instanceId>.json` file is a JSON object with the following fields:
  - `instanceId` (string, required): stable instance identifier (UUID recommended).
  - `pid` (number|null): process id of the instance when available.
  - `listenAddr` (string, required): transport address (e.g., `127.0.0.1:54321` or `/tmp/brokk.sock`).
  - `project` (string|null): optional project/workspace root path.
  - `brokkctlVersion` (string): protocol version the instance advertises (semantic-ish `MAJOR.MINOR.PATCH`).
  - `supportedCapabilities` (optional array): capability descriptors the instance returns.
  - `startedAt` (number): epoch ms when the instance started.
  - `lastSeenMs` (number): epoch ms of the most recent heartbeat/update from the instance.
  - `platform` (optional string): short platform hint (e.g., `linux`, `darwin`, `windows`).
  - `listenProtocol` (optional string): e.g., `http`, `unix`, `namedpipe`.
- Example file name: `550e8400-e29b-41d4-a716-446655440000.json`

Heartbeat and TTL
- Instances MUST update `lastSeenMs` periodically (heartbeat). A reasonable default heartbeat interval is 5 seconds.
- `brokkctl` and other readers SHOULD consider an entry stale if `now - lastSeenMs > TTL`. Recommended default TTL: 30 seconds.
- On clean shutdown the instance SHOULD remove its file from the registry directory. Files left behind (unremoved) will be treated as stale and will be pruned.

Cleanup rules
- Because instances may crash or be killed, registry cleanup is cooperative:
  - Instances remove their file on clean exit.
  - Readers (like `brokkctl`) SHOULD ignore stale entries older than TTL.
  - `brokkctl` MAY expose a `instances prune` command that removes stale files (only when run by the same user who owns the registry directory).
  - Implementations SHOULD provide safe atomic deletion (unlink) and avoid assuming permission to modify other users' entries.
- Filesystem semantics:
  - Use one file per instance to allow simple atomic create/replace/delete semantics.
  - When updating, write to a temporary file and rename to replace the prior file atomically.

Selection rules and CLI flags
- `--instance <selector>`: select a specific instance. The selector formats supported SHOULD include:
  - Instance ID (UUID): `550e84...`
  - PID selector: `pid:12345`
  - Listen address: `addr:127.0.0.1:54321` or raw `127.0.0.1:54321`
  - Socket path: `socket:/tmp/brokk.sock`
- `--all`: target all non-stale instances (fan-out). When used, results MUST be an aggregated shape with per-instance entries and a summary.
- `--auto-select`: non-interactive, deterministic auto-selection. When present, choose the instance using this deterministic priority:
  1. The sole non-stale instance, if exactly one exists.
  2. Instance with most recent `lastSeenMs`.
  3. Tie-breaker: highest `pid` (numeric) to make selection deterministic.
- Default behavior (no selector and no `--all`):
  - If zero non-stale instances found: return a deterministic error recommending `--instance` or `--auto-select`.
  - If exactly one non-stale instance found: select it automatically.
  - If multiple non-stale instances and running in an interactive TTY: prompt the user to choose.
  - If multiple and non-interactive (e.g., scripts, CI): fail deterministically and require `--instance`, `--all`, or `--auto-select`.
- Interaction semantics:
  - Interactive prompts MUST include `instanceId`, `pid`, `listenAddr`, `project`, and `brokkctlVersion` to help the user choose.

Fan-out semantics and aggregation
- `instances list` is naturally fan-out and returns raw discovery records.
- Operational commands target a single instance by default. If a command supports explicit multi-instance execution, results MUST include:
  - `summary`: { requested, succeeded, failed }
  - `results`: [{ instanceId, status, data?, error? }, ...]
- Mixed outcomes map to exit code `3` (partial failure) when `-o json` is used; otherwise the CLI should surface a clear message and a non-zero exit code.

Security:
- The CLI must accept `--auth-token` and send `Authorization: Bearer <token>` to secured endpoints.
- Tokens are local-only by default; remote deployments require appropriate operational security.

Aggregation:
- For fan-out calls, return:
  - `summary`: { requested, succeeded, failed }
  - `results`: [{ instanceId, status, data?, error? }, ...]
- Mixed outcomes map to exit code `3` (partial failure) when `-o json` is used; otherwise the CLI should surface a clear message and a non-zero exit code.

Security:
- The CLI must accept `--auth-token` and send `Authorization: Bearer <token>` to secured endpoints.
- Tokens are local-only by default; remote deployments require appropriate operational security.

## Output & Exit Codes

- `--format json` is the canonical machine format (use NDJSON for streaming/event feeds when `--follow` or similar is used).
- Human-friendly output (`text`) is a presentation-layer concern.
- For streaming events prefer NDJSON (newline-delimited JSON) for line-by-line tooling compatibility.

Exit code mapping (recommended):
- `0` — SUCCESS: All requested operations succeeded.
- `1` — USER_ERROR: Invalid arguments, missing required flags, or other client-side usage errors.
- `2` — TRANSPORT_ERROR: Network-level failures, request timeouts, or discovery failures.
- `3` — AUTH_ERROR: Authentication/authorization failures (e.g., 401/403).
- `4` — PARTIAL_SUCCESS: Fan-out operations completed with a mix of successes and failures.

Semantics and rules:
- Any non-zero exit code indicates failure for automation. `4` explicitly denotes partial success and allows callers to detect mixed outcomes.
- `--fail-fast`: the CLI should return immediately on the first error using the appropriate error category code (USER_ERROR/TRANSPORT_ERROR/AUTH_ERROR).
- `--best-effort`: the CLI should attempt all targets and then:
  - If at least one target succeeded and at least one failed, return `4` (PARTIAL_SUCCESS).
  - If all targets failed, return the highest-priority non-zero error encountered. Priority order for collapsing multiple error types: AUTH_ERROR (3) > TRANSPORT_ERROR (2) > USER_ERROR (1).
- In `json` mode error responses MUST follow the structured shape:
{
  "error": {
    "code": "USER_ERROR",
    "message": "Detailed text",
    "details": { ... optional ... }
  }
}
- For fan-out responses include a `summary` and per-instance `results` (each result may include `error`); in mixed-outcome cases return exit code `4`.

## Versioning Strategy — `brokkctl` Protocol

To enable safe evolution between clients (`brokkctl`) and instances, we introduce a lightweight protocol version header and negotiation rules.

Header name:
- `Brokk-CTL-Version` — included on discovery and all subsequent control requests/responses.

Version format:
- Semantic-ish: `MAJOR.MINOR.PATCH` (e.g., `1.0.0`).
  - MAJOR: breaking changes
  - MINOR: backward-compatible feature additions
  - PATCH: bug fixes only

Compatibility rules:
- Same MAJOR: client and server MAY attempt to proceed.
  - If server.MINOR >= client.MINOR: expected to support client's requested features.
  - If server.MINOR < client.MINOR: the server must return a structured error describing unsupported features (error code `PROTOCOL_UNSUPPORTED_FEATURE`) and list supported capabilities; the client should either degrade or abort.
- Different MAJOR:
  - If client.MAJOR < server.MAJOR: server MAY support older clients; client should be prepared for `PROTOCOL_UNSUPPORTED_FEATURE` errors.
  - If client.MAJOR > server.MAJOR: client SHOULD refuse to proceed automatically. Require `--allow-incompatible` to proceed (explicit opt-in).
- PATCH differences are safe; do not affect protocol semantics.

Negotiation:
- Discovery descriptors MUST include `brokkctlVersion`.
- Clients SHOULD include `Brokk-CTL-Version: <client-version>` in requests.
- Servers SHOULD respond with a `Brokk-CTL-Version` response header equal to their implemented version.
- If a requested capability is missing, the server responds with `HTTP 409` (or other appropriate status) and a JSON error body containing:
  - `code: "PROTOCOL_UNSUPPORTED_FEATURE"`
  - `message: "Feature X requires brokkctl >= MAJOR.MINOR"`
  - optional `supportedCapabilities` list with minimal required versions.

Backward-compatibility policies (quick reference):
- Client MAJOR == Server MAJOR:
  - Server.MINOR < Client.MINOR → client must detect unsupported capability errors and either degrade or abort with a clear explanation.
  - Server.MINOR >= Client.MINOR → features should work.
- Client MAJOR != Server MAJOR:
  - Client.MAJOR > Server.MAJOR → require explicit `--allow-incompatible`.
  - Client.MAJOR < Server.MAJOR → proceed but handle server-provided errors.
- Always expose server `brokkctlVersion` in CLI output so automation can adapt.

Capabilities declaration:
- Servers SHOULD expose a discovery endpoint (e.g., `GET /v1/ctl-info`) returning:
  - `brokkctlVersion` (string)
  - `instanceId`, `pid`, `project`, `listenAddr`
  - `supportedCapabilities`: [{ "name": "sessions.import", "minVersion": "1.1.0" }, ...]
- Clients can use `supportedCapabilities` to decide safe fallbacks.

## Error Model

- Always return structured JSON errors in `-o json` mode.
- Distinguish discovery/network-level errors from operation-level errors.
- For fan-out operations return per-instance `error` and a top-level `summary`.
- Use consistent, enumerated error codes (e.g., `INVALID_ARGS`, `NOT_FOUND`, `UNAUTHORIZED`, `BUSY`, `PROTOCOL_UNSUPPORTED_FEATURE`, `INTERNAL_ERROR`).

## Next Steps (implementation hints)

- Implement a `ctl-info` discovery/health endpoint in the application that returns `brokkctlVersion`, instance metadata, and capabilities.
- Choose a platform-appropriate discovery mechanism for local instances.
- Implement `-o json` surfaces first; add human-friendly formatting later.
- Add tests that exercise negotiation rules:
  - Client requesting a MINOR-level feature against a lower-MINOR server
  - Major version mismatch handling and `--allow-incompatible` opt-in
  - Fan-out aggregation with mixed results
- Document recommended exit codes and JSON shapes for consumers (CI scripts, orchestration systems).

## JSON Envelope Schemas

This section defines the canonical JSON envelope shapes that `brokkctl` and Brokk instances should produce and accept for non-streaming operations. These envelopes standardize request correlation, per-instance results, aggregated fan-out responses, and error reporting so automation can reliably correlate and react to outcomes.

Top-level conventions
- Every client-initiated request SHOULD include a `requestId` (string, UUID recommended) to allow correlation across retries, logs, and aggregated responses.
- Per-instance results MUST include `instanceId` and a `status` field. If an instance returns an error, include an `error` object following the canonical Error shape below.
- Fan-out responses MUST include an aggregated `summary` and a `results` array with per-instance containers.
- For streaming endpoints use NDJSON where each line is a JSON envelope; each event line SHOULD include `requestId` and `instanceId` when applicable.

1) Canonical request envelope (client → instance)

```json
{
  "requestId": "550e8400-e29b-41d4-a716-446655440000",
  "createdAtMs": 1690000000000,
  "command": "execution.submit",
  "protocolVersion": "1.0.0",
  "payload": {
    /* command-specific body, e.g. JobSpec */
  }
}
```

Fields:
- `requestId` (string, required): opaque correlation id assigned by the client.
- `createdAtMs` (number, optional): epoch ms when the request was created.
- `command` (string, required): logical command name (e.g., `sessions.create`, `execution.submit`).
- `protocolVersion` (string, optional): client's `Brokk-CTL-Version` (MAJOR.MINOR.PATCH).
- `payload` (object, optional): command-specific parameters.

2) Canonical per-instance result container

```json
{
  "instanceId": "550e8400-e29b-41d4-a716-446655440000",
  "listenAddr": "127.0.0.1:54321",
  "status": "ok",
  "data": { /* optional success payload */ },
  "error": null,
  "elapsedMs": 123
}
```

Or on failure:

```json
{
  "instanceId": "550e8400-e29b-41d4-a716-446655440000",
  "listenAddr": "127.0.0.1:54321",
  "status": "error",
  "data": null,
  "error": {
    "code": "BUSY",
    "message": "instance is busy",
    "details": { "retryAfterMs": 5000 }
  },
  "elapsedMs": 45
}
```

Fields:
- `instanceId` (string, required): instance identifier.
- `listenAddr` (string, optional): endpoint used for the request (helpful for debugging).
- `status` (string, required): one of `"ok"`, `"error"`, or `"skipped"`.
- `data` (object|null): command-specific success payload when `status == "ok"`.
- `error` (Error|null): present when `status == "error"`; must follow the canonical Error shape.
- `elapsedMs` (number, optional): milliseconds the instance spent handling the request (instrumentation).

3) Canonical Error object shape

```json
{
  "code": "PROTOCOL_UNSUPPORTED_FEATURE",
  "message": "Feature 'sessions.import' requires brokkctl >= 1.1.0 (server: 1.0.0)",
  "details": {
    "serverVersion": "1.0.0",
    "requiredVersion": "1.1.0",
    "supportedCapabilities": [
      { "name": "sessions.create", "minVersion": "1.0.0" }
    ]
  }
}
```

Fields:
- `code` (string, required): short machine-friendly error code (enumerated values encouraged, e.g., `INVALID_ARGS`, `NOT_FOUND`, `UNAUTHORIZED`, `BUSY`, `PROTOCOL_UNSUPPORTED_FEATURE`, `INTERNAL_ERROR`).
- `message` (string, required): human-consumable explanation suitable for logs and UI.
- `details` (object, optional): structured diagnostic data helpful for programmatic decisions (versions, URLs, retry hints, capability lists, etc.).

4) Aggregate fan-out response (client receives)

```json
{
  "requestId": "550e8400-e29b-41d4-a716-446655440000",
  "summary": { "requested": 3, "succeeded": 2, "failed": 1 },
  "results": [
    {
      "instanceId": "a",
      "status": "ok",
      "data": { /* command-specific */ },
      "error": null
    },
    {
      "instanceId": "b",
      "status": "ok",
      "data": { /* command-specific */ },
      "error": null
    },
    {
      "instanceId": "c",
      "status": "error",
      "data": null,
      "error": {
        "code": "BUSY",
        "message": "instance is busy",
        "details": {}
      }
    }
  ],
  "elapsedMs": 215
}
```

Fields:
- `requestId` (string, required): mirrors the client's requestId for easy correlation.
- `summary` (object, required): aggregate counts `{ requested, succeeded, failed }`.
- `results` (array, required): array of per-instance result containers.
- `elapsedMs` (number, optional): overall time from the client's perspective.

Exit code mapping (json-mode)
- On all-success: exit code `0`.
- On per-instance mixed results: exit code `4` (PARTIAL_SUCCESS).
- On global failure: appropriate non-zero (see spec mapping for USER_ERROR, TRANSPORT_ERROR, AUTH_ERROR).

Streaming (NDJSON) variant
- For streaming endpoints (e.g., `execution events --follow`) use NDJSON where each line is either:
  - an event envelope: `{ "requestId": "...", "instanceId": "...", "eventType": "stdout|job.event|job.complete", "event": { ... } }`
  - or an error envelope: `{ "requestId": "...", "instanceId": "...", "error": { ... } }`
- Each NDJSON line MUST be parseable as a self-contained JSON object and SHOULD include `requestId` and `instanceId` when applicable.

5) Example: protocol unsupported feature error (uses canonical Error shape)

```json
{
  "requestId": "550e8400-e29b-41d4-a716-446655440000",
  "error": {
    "code": "PROTOCOL_UNSUPPORTED_FEATURE",
    "message": "Feature 'sessions.import' requires brokkctl >= 1.1.0 (server: 1.0.0)",
    "details": {
      "serverVersion": "1.0.0",
      "requiredVersion": "1.1.0",
      "supportedCapabilities": [
        { "name": "sessions.create", "minVersion": "1.0.0" }
      ]
    }
  }
}
```

## Appendix: Example Shapes

Instance descriptor (discovery)
```json
{
  "instanceId": "550e8400-e29b-41d4-a716-446655440000",
  "pid": 12345,
  "listenAddr": "127.0.0.1:54321",
  "project": "/home/alice/my-repo",
  "brokkctlVersion": "1.0.0",
  "lastSeenMs": 1690000000000
}
```

Fan-out response (uses canonical envelopes)
```json
{
  "requestId": "550e8400-e29b-41d4-a716-446655440000",
  "summary": { "requested": 3, "succeeded": 2, "failed": 1 },
  "results": [
    { "instanceId":"a","status":"ok","data":{ /* ... */ }, "error": null },
    { "instanceId":"b","status":"ok","data":{ /* ... */ }, "error": null },
    { "instanceId":"c","status":"error","data":null,"error":{"code":"BUSY","message":"instance is busy"} }
  ]
}
```

---
This specification is intentionally concise and implementation-agnostic while providing actionable rules for discovery, negotiation, compatibility, error handling, and output shapes. The next phase is a reference implementation that selects a discovery mechanism and wires the `ctl-info` endpoint on the Brokk side and a minimal `brokkctl` client that implements the negotiation and JSON-first output.
