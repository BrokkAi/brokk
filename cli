# brokkctl — CLI Controller Specification (Spike)

This document specifies a small, focused CLI controller — working name `brokkctl` — that discovers and talks to running Brokk desktop processes and presents a machine-friendly, JSON-first automation surface. This is a specification-only spike: it defines the surface, semantics, and versioning rules needed to implement a CLI controller and compatible MCP/REST/AppleScript endpoints. It does not prescribe implementation details or require changes to Brokk internals.

## Overview

`brokkctl` is an orchestration layer intended for automation and scripting. Its responsibilities are:

- Discover local Brokk instances that expose a control endpoint.
- Send commands to one or more instances and aggregate responses.
- Provide a stable, machine-readable JSON API for automation; human-friendly output is optional.
- Negotiate capabilities and compatibility via a lightweight protocol version.

This spec is implementation-agnostic: discovery can be implemented by registry, socket probing, mDNS, or another platform-appropriate mechanism. The important part is the semantics and compatibility guarantees offered to clients.

## Goals

- Define a stable, machine-friendly CLI surface for common automation tasks:
  - Instance discovery and selection
  - Project open/list/get actions
  - Session create/list/get/import/export
  - Context manipulation (add files/classes/methods/text)
  - Querying session output / history
  - Execution control: submit/stream/cancel jobs (ASK, SEARCH, CODE, ARCHITECT, LUTZ)
- Make JSON the canonical output mode (`-o json`), with NDJSON for streaming event feeds.
- Support multi-instance fan-out with well-defined per-instance and aggregate results.
- Provide a versioned protocol and compatibility policy enabling graceful client and server evolution.
- Produce a concise, testable spec to guide implementations in the application and a standalone `brokkctl` tool.

## Non-goals

- This is a spec-only spike. It does not modify application core logic, private storage formats, or internal behavior.
- The spec does not mandate a discovery transport (mDNS vs sockets vs registry). Implementers choose platform-appropriate mechanisms.
- This document does not provide exhaustive CLI UX text (help output). Those are implementation details.
- No runtime behavioral changes to the Brokk desktop application are required by this spec.

## Terminology

- instance  
  A running Brokk process that exposes a local control endpoint (MCP/HTTP/stdio). An instance is identified by an `instanceId` and a discovery descriptor (listen address, PID when available, socket path, etc.).

- project  
  The code workspace currently open in an instance. This is typically a repository root or workspace folder.

- session  
  A Brokk session (user session) representing a workspace snapshot, context, configuration, and transcript/history. Sessions are created, imported, exported, and selected inside an instance.

- context  
  Additional data seeded into a session to influence LLM reasoning: files, class summaries, method sources, or free-form text fragments. Context entries are addressable (IDs) and may be session- or job-scoped.

- history  
  The session transcript and action history: sequence of task entries, LLM outputs, notifications, diffs, and related metadata. Useful for resuming work or exporting results.

- execution (job)  
  A unit of work submitted to an instance for processing. Executions have modes (ASK, SEARCH, CODE, ARCHITECT, LUTZ), accept a `JobSpec` (sessionId, taskInput, models, flags), produce streamable events, and end with a `JobStatus` and optional diff.

## CLI Command Surface (conceptual)

Top-level command: `brokkctl`

Global flags:
- `--format json|text` — output format; `json` is the canonical machine-friendly default. `text` yields human-oriented pretty output.
- `--instance <selector>` — target a specific instance. Supported selector forms: instanceId (UUID), `pid:<n>`, `addr:<host:port>`, `socket:<path>`.
- `--all` — target all non-stale instances (fan-out).
- `--timeout <ms>` — overall timeout in milliseconds for discovery and per-request network operations (default: 30000).
- `--fail-fast` / `--best-effort` — fan-out failure policy. `--fail-fast` aborts on first failure (default); `--best-effort` attempts all targets and returns an aggregated result (partial success possible).
- `--protocol-version <MAJOR.MINOR.PATCH>` — advertise a specific client protocol version via the `Brokk-CTL-Version` header; if omitted the client will use its built-in version.
- `--auth-token <token>` — send `Authorization: Bearer <token>` to secured endpoints.
- `--allow-incompatible` — explicitly allow proceeding when client MAJOR > server MAJOR (dangerous; requires opt-in).

Example subcommands (conceptual):
- `brokkctl instances list` — list discovered instances
- `brokkctl project open --path <path>` — open a project in an instance
- `brokkctl sessions create --name <name>` — create a session
- `brokkctl sessions import --file <session.zip>` — import a session zip
- `brokkctl context add-file --path <relPath>` — add files to session context
- `brokkctl execution submit --session <id> --mode <MODE> --planner-model <model> --task "..."` — submit a job
- `brokkctl execution events --job <jobId> --follow` — stream job events (NDJSON)
- `brokkctl execution cancel --job <jobId>` — cancel job
- `brokkctl history get --session <id> --limit N` — fetch session history

All commands must support `-o json` and return structured JSON for automation. Streaming endpoints should use NDJSON or SSE with an option to pass through raw server stream.

## Discovery & Multi-instance Handling

Discovery semantics:
- `brokkctl` must discover zero or more instances and return descriptors with:
  - `instanceId` (string)
  - `pid` (optional)
  - `listenAddr` (host:port or socket path)
  - `project` (if available)
  - `brokkctlVersion` (protocol version the instance speaks)
  - `lastSeenMs` (timestamp hint for stability)

Registry location
- The instance registry is per-user and uses the platform's conventional user config directory. Implementations SHOULD store instance records as individual files in a directory to avoid write-contention and to allow atomic add/remove. Recommended locations:
  - Linux: `$XDG_CONFIG_HOME/brokk/instances/` (fallback: `$HOME/.config/brokk/instances/`)
  - macOS: `~/Library/Application Support/Brokk/instances/`
  - Windows: `%APPDATA%\Brokk\instances\`
- Each instance writes a single file named `<instanceId>.json` into the registry directory. Files MUST be written atomically (write temporary file then rename) to avoid partial reads.

Record schema
- Each `<instanceId>.json` file is a JSON object with the following fields:
  - `instanceId` (string, required): stable instance identifier (UUID recommended).
  - `pid` (number|null): process id of the instance when available.
  - `listenAddr` (string, required): transport address (e.g., `127.0.0.1:54321` or `/tmp/brokk.sock`).
  - `project` (string|null): optional project/workspace root path.
  - `brokkctlVersion` (string): protocol version the instance advertises (semantic-ish `MAJOR.MINOR.PATCH`).
  - `supportedCapabilities` (optional array): capability descriptors the instance returns.
  - `startedAt` (number): epoch ms when the instance started.
  - `lastSeenMs` (number): epoch ms of the most recent heartbeat/update from the instance.
  - `platform` (optional string): short platform hint (e.g., `linux`, `darwin`, `windows`).
  - `listenProtocol` (optional string): e.g., `http`, `unix`, `namedpipe`.
- Example file name: `550e8400-e29b-41d4-a716-446655440000.json`

Heartbeat and TTL
- Instances MUST update `lastSeenMs` periodically (heartbeat). A reasonable default heartbeat interval is 5 seconds.
- `brokkctl` and other readers SHOULD consider an entry stale if `now - lastSeenMs > TTL`. Recommended default TTL: 30 seconds.
- On clean shutdown the instance SHOULD remove its file from the registry directory. Files left behind (unremoved) will be treated as stale and will be pruned.

Cleanup rules
- Because instances may crash or be killed, registry cleanup is cooperative:
  - Instances remove their file on clean exit.
  - Readers (like `brokkctl`) SHOULD ignore stale entries older than TTL.
  - `brokkctl` MAY expose a `instances prune` command that removes stale files (only when run by the same user who owns the registry directory).
  - Implementations SHOULD provide safe atomic deletion (unlink) and avoid assuming permission to modify other users' entries.
- Filesystem semantics:
  - Use one file per instance to allow simple atomic create/replace/delete semantics.
  - When updating, write to a temporary file and rename to replace the prior file atomically.

Selection rules and CLI flags
- `--instance <selector>`: select a specific instance. The selector formats supported SHOULD include:
  - Instance ID (UUID): `550e84...`
  - PID selector: `pid:12345`
  - Listen address: `addr:127.0.0.1:54321` or raw `127.0.0.1:54321`
  - Socket path: `socket:/tmp/brokk.sock`
- `--all`: target all non-stale instances (fan-out). When used, results MUST be an aggregated shape with per-instance entries and a summary.
- `--auto-select`: non-interactive, deterministic auto-selection. When present, choose the instance using this deterministic priority:
  1. The sole non-stale instance, if exactly one exists.
  2. Instance with most recent `lastSeenMs`.
  3. Tie-breaker: highest `pid` (numeric) to make selection deterministic.
- Default behavior (no selector and no `--all`):
  - If zero non-stale instances found: return a deterministic error recommending `--instance` or `--auto-select`.
  - If exactly one non-stale instance found: select it automatically.
  - If multiple non-stale instances and running in an interactive TTY: prompt the user to choose.
  - If multiple and non-interactive (e.g., scripts, CI): fail deterministically and require `--instance`, `--all`, or `--auto-select`.
- Interaction semantics:
  - Interactive prompts MUST include `instanceId`, `pid`, `listenAddr`, `project`, and `brokkctlVersion` to help the user choose.

Fan-out semantics and aggregation
- `instances list` is naturally fan-out and returns raw discovery records.
- Operational commands target a single instance by default. If a command supports explicit multi-instance execution, results MUST include:
  - `summary`: { requested, succeeded, failed }
  - `results`: [{ instanceId, status, data?, error? }, ...]
- Mixed outcomes map to exit code `3` (partial failure) when `-o json` is used; otherwise the CLI should surface a clear message and a non-zero exit code.

Security:
- The CLI must accept `--auth-token` and send `Authorization: Bearer <token>` to secured endpoints.
- Tokens are local-only by default; remote deployments require appropriate operational security.

Aggregation:
- For fan-out calls, return:
  - `summary`: { requested, succeeded, failed }
  - `results`: [{ instanceId, status, data?, error? }, ...]
- Mixed outcomes map to exit code `3` (partial failure) when `-o json` is used; otherwise the CLI should surface a clear message and a non-zero exit code.

Security:
- The CLI must accept `--auth-token` and send `Authorization: Bearer <token>` to secured endpoints.
- Tokens are local-only by default; remote deployments require appropriate operational security.

## Output & Exit Codes

- `--format json` is the canonical machine format (use NDJSON for streaming/event feeds when `--follow` or similar is used).
- Human-friendly output (`text`) is a presentation-layer concern.
- For streaming events prefer NDJSON (newline-delimited JSON) for line-by-line tooling compatibility.

Exit code mapping (recommended):
- `0` — SUCCESS: All requested operations succeeded.
- `1` — USER_ERROR: Invalid arguments, missing required flags, or other client-side usage errors.
- `2` — TRANSPORT_ERROR: Network-level failures, request timeouts, or discovery failures.
- `3` — AUTH_ERROR: Authentication/authorization failures (e.g., 401/403).
- `4` — PARTIAL_SUCCESS: Fan-out operations completed with a mix of successes and failures.

Semantics and rules:
- Any non-zero exit code indicates failure for automation. `4` explicitly denotes partial success and allows callers to detect mixed outcomes.
- `--fail-fast`: the CLI should return immediately on the first error using the appropriate error category code (USER_ERROR/TRANSPORT_ERROR/AUTH_ERROR).
- `--best-effort`: the CLI should attempt all targets and then:
  - If at least one target succeeded and at least one failed, return `4` (PARTIAL_SUCCESS).
  - If all targets failed, return the highest-priority non-zero error encountered. Priority order for collapsing multiple error types: AUTH_ERROR (3) > TRANSPORT_ERROR (2) > USER_ERROR (1).
- In `json` mode error responses MUST follow the structured shape:
{
  "error": {
    "code": "USER_ERROR",
    "message": "Detailed text",
    "details": { ... optional ... }
  }
}
- For fan-out responses include a `summary` and per-instance `results` (each result may include `error`); in mixed-outcome cases return exit code `4`.

## Versioning Strategy — `brokkctl` Protocol

To enable safe evolution between clients (`brokkctl`) and instances, we introduce a lightweight protocol version header and negotiation rules.

Header name:
- `Brokk-CTL-Version` — included on discovery and all subsequent control requests/responses.

Version format:
- Semantic-ish: `MAJOR.MINOR.PATCH` (e.g., `1.0.0`).
  - MAJOR: breaking changes
  - MINOR: backward-compatible feature additions
  - PATCH: bug fixes only

Compatibility rules:
- Same MAJOR: client and server MAY attempt to proceed.
  - If server.MINOR >= client.MINOR: expected to support client's requested features.
  - If server.MINOR < client.MINOR: the server must return a structured error describing unsupported features (error code `PROTOCOL_UNSUPPORTED_FEATURE`) and list supported capabilities; the client should either degrade or abort.
- Different MAJOR:
  - If client.MAJOR < server.MAJOR: server MAY support older clients; client should be prepared for `PROTOCOL_UNSUPPORTED_FEATURE` errors.
  - If client.MAJOR > server.MAJOR: client SHOULD refuse to proceed automatically. Require `--allow-incompatible` to proceed (explicit opt-in).
- PATCH differences are safe; do not affect protocol semantics.

Negotiation:
- Discovery descriptors MUST include `brokkctlVersion`.
- Clients SHOULD include `Brokk-CTL-Version: <client-version>` in requests.
- Servers SHOULD respond with a `Brokk-CTL-Version` response header equal to their implemented version.
- If a requested capability is missing, the server responds with `HTTP 409` (or other appropriate status) and a JSON error body containing:
  - `code: "PROTOCOL_UNSUPPORTED_FEATURE"`
  - `message: "Feature X requires brokkctl >= MAJOR.MINOR"`
  - optional `supportedCapabilities` list with minimal required versions.

Backward-compatibility policies (quick reference):
- Client MAJOR == Server MAJOR:
  - Server.MINOR < Client.MINOR → client must detect unsupported capability errors and either degrade or abort with a clear explanation.
  - Server.MINOR >= Client.MINOR → features should work.
- Client MAJOR != Server MAJOR:
  - Client.MAJOR > Server.MAJOR → require explicit `--allow-incompatible`.
  - Client.MAJOR < Server.MAJOR → proceed but handle server-provided errors.
- Always expose server `brokkctlVersion` in CLI output so automation can adapt.

Capabilities declaration:
- Servers SHOULD expose a discovery endpoint (e.g., `GET /v1/ctl-info`) returning:
  - `brokkctlVersion` (string)
  - `instanceId`, `pid`, `project`, `listenAddr`
  - `supportedCapabilities`: [{ "name": "sessions.import", "minVersion": "1.1.0" }, ...]
- Clients can use `supportedCapabilities` to decide safe fallbacks.

## Error Model

- Always return structured JSON errors in `-o json` mode.
- Distinguish discovery/network-level errors from operation-level errors.
- For fan-out operations return per-instance `error` and a top-level `summary`.
- Use consistent, enumerated error codes (e.g., `INVALID_ARGS`, `NOT_FOUND`, `UNAUTHORIZED`, `BUSY`, `PROTOCOL_UNSUPPORTED_FEATURE`, `INTERNAL_ERROR`).

## Next Steps (implementation hints)

- Implement a `ctl-info` discovery/health endpoint in the application that returns `brokkctlVersion`, instance metadata, and capabilities.
- Choose a platform-appropriate discovery mechanism for local instances.
- Implement `-o json` surfaces first; add human-friendly formatting later.
- Add tests that exercise negotiation rules:
  - Client requesting a MINOR-level feature against a lower-MINOR server
  - Major version mismatch handling and `--allow-incompatible` opt-in
  - Fan-out aggregation with mixed results
- Document recommended exit codes and JSON shapes for consumers (CI scripts, orchestration systems).

## JSON Envelope Schemas

This section defines the canonical JSON envelope shapes that `brokkctl` and Brokk instances should produce and accept for non-streaming operations. These envelopes standardize request correlation, per-instance results, aggregated fan-out responses, and error reporting so automation can reliably correlate and react to outcomes.

Top-level conventions
- Every client-initiated request SHOULD include a `requestId` (string, UUID recommended) to allow correlation across retries, logs, and aggregated responses.
- Per-instance results MUST include `instanceId` and a `status` field. If an instance returns an error, include an `error` object following the canonical Error shape below.
- Fan-out responses MUST include an aggregated `summary` and a `results` array with per-instance containers.
- For streaming endpoints use NDJSON where each line is a JSON envelope; each event line SHOULD include `requestId` and `instanceId` when applicable.

1) Canonical request envelope (client → instance)

```json
{
  "requestId": "550e8400-e29b-41d4-a716-446655440000",
  "createdAtMs": 1690000000000,
  "command": "execution.submit",
  "protocolVersion": "1.0.0",
  "payload": {
    /* command-specific body, e.g. JobSpec */
  }
}
```

Fields:
- `requestId` (string, required): opaque correlation id assigned by the client.
- `createdAtMs` (number, optional): epoch ms when the request was created.
- `command` (string, required): logical command name (e.g., `sessions.create`, `execution.submit`).
- `protocolVersion` (string, optional): client's `Brokk-CTL-Version` (MAJOR.MINOR.PATCH).
- `payload` (object, optional): command-specific parameters.

2) Canonical per-instance result container

```json
{
  "instanceId": "550e8400-e29b-41d4-a716-446655440000",
  "listenAddr": "127.0.0.1:54321",
  "status": "ok",
  "data": { /* optional success payload */ },
  "error": null,
  "elapsedMs": 123
}
```

Or on failure:

```json
{
  "instanceId": "550e8400-e29b-41d4-a716-446655440000",
  "listenAddr": "127.0.0.1:54321",
  "status": "error",
  "data": null,
  "error": {
    "code": "BUSY",
    "message": "instance is busy",
    "details": { "retryAfterMs": 5000 }
  },
  "elapsedMs": 45
}
```

Fields:
- `instanceId` (string, required): instance identifier.
- `listenAddr` (string, optional): endpoint used for the request (helpful for debugging).
- `status` (string, required): one of `"ok"`, `"error"`, or `"skipped"`.
- `data` (object|null): command-specific success payload when `status == "ok"`.
- `error` (Error|null): present when `status == "error"`; must follow the canonical Error shape.
- `elapsedMs` (number, optional): milliseconds the instance spent handling the request (instrumentation).

3) Canonical Error object shape

```json
{
  "code": "PROTOCOL_UNSUPPORTED_FEATURE",
  "message": "Feature 'sessions.import' requires brokkctl >= 1.1.0 (server: 1.0.0)",
  "details": {
    "serverVersion": "1.0.0",
    "requiredVersion": "1.1.0",
    "supportedCapabilities": [
      { "name": "sessions.create", "minVersion": "1.0.0" }
    ]
  }
}
```

Fields:
- `code` (string, required): short machine-friendly error code (enumerated values encouraged, e.g., `INVALID_ARGS`, `NOT_FOUND`, `UNAUTHORIZED`, `BUSY`, `PROTOCOL_UNSUPPORTED_FEATURE`, `INTERNAL_ERROR`).
- `message` (string, required): human-consumable explanation suitable for logs and UI.
- `details` (object, optional): structured diagnostic data helpful for programmatic decisions (versions, URLs, retry hints, capability lists, etc.).

4) Aggregate fan-out response (client receives)

```json
{
  "requestId": "550e8400-e29b-41d4-a716-446655440000",
  "summary": { "requested": 3, "succeeded": 2, "failed": 1 },
  "results": [
    {
      "instanceId": "a",
      "status": "ok",
      "data": { /* command-specific */ },
      "error": null
    },
    {
      "instanceId": "b",
      "status": "ok",
      "data": { /* command-specific */ },
      "error": null
    },
    {
      "instanceId": "c",
      "status": "error",
      "data": null,
      "error": {
        "code": "BUSY",
        "message": "instance is busy",
        "details": {}
      }
    }
  ],
  "elapsedMs": 215
}
```

Fields:
- `requestId` (string, required): mirrors the client's requestId for easy correlation.
- `summary` (object, required): aggregate counts `{ requested, succeeded, failed }`.
- `results` (array, required): array of per-instance result containers.
- `elapsedMs` (number, optional): overall time from the client's perspective.

Exit code mapping (json-mode)
- On all-success: exit code `0`.
- On per-instance mixed results: exit code `4` (PARTIAL_SUCCESS).
- On global failure: appropriate non-zero (see spec mapping for USER_ERROR, TRANSPORT_ERROR, AUTH_ERROR).

Streaming (NDJSON) variant
- For streaming endpoints (e.g., `execution events --follow`) use NDJSON where each line is either:
  - an event envelope: `{ "requestId": "...", "instanceId": "...", "eventType": "stdout|job.event|job.complete", "event": { ... } }`
  - or an error envelope: `{ "requestId": "...", "instanceId": "...", "error": { ... } }`
- Each NDJSON line MUST be parseable as a self-contained JSON object and SHOULD include `requestId` and `instanceId` when applicable.

5) Example: protocol unsupported feature error (uses canonical Error shape)

```json
{
  "requestId": "550e8400-e29b-41d4-a716-446655440000",
  "error": {
    "code": "PROTOCOL_UNSUPPORTED_FEATURE",
    "message": "Feature 'sessions.import' requires brokkctl >= 1.1.0 (server: 1.0.0)",
    "details": {
      "serverVersion": "1.0.0",
      "requiredVersion": "1.1.0",
      "supportedCapabilities": [
        { "name": "sessions.create", "minVersion": "1.0.0" }
      ]
    }
  }
}
```

## Instances list — command specification

This section specifies the `brokkctl instances list` command in detail: inputs, output schema, and example responses for the common cases (0, 1, many instances). It also documents how stale/unreachable instances are represented when `--all` is used.

Purpose
- Enumerate discovered Brokk instances visible to the current user.
- By default, return *non-stale* (i.e., "online") entries only. Use `--all` to include stale and potentially unreachable records left in the registry.

Inputs / Flags
- `--format json|text` (global): output format. `json` is canonical.
- `--all` (optional): include stale registry entries (entries older than the TTL). When omitted, stale entries are filtered out.
- `--ttl <ms>` (optional): override TTL used to decide staleness for this invocation (default: 30000 ms).
- `--request-id <uuid>` (optional): client-supplied requestId for correlation. If omitted, the client generates one.
- `--timeout <ms>` (optional): discovery timeout. Defaults to global timeout.
- `--auth-token <token>` (optional): used when querying endpoints to verify reachability.

Behavioral rules
- Default (no `--all`): return only entries where `now - lastSeenMs <= TTL`.
- With `--all`: return all registry entries, but mark stale and unreachable entries with explicit status fields.
- If an entry appears stale (lastSeenMs older than TTL), the entry's `status` becomes `"stale"`. A stale entry may still be reachable if the client can connect to its `listenAddr`. The client SHOULD attempt a lightweight reachability probe (e.g., `ctl-info`) only when `--all` is used or when an explicit `--probe` flag is present (to avoid unnecessary network calls during discovery).
- If a previously-written registry file exists but the instance cannot be reached (connection refused, auth failure, etc.), the entry `status` becomes `"unreachable"` and an `error` object is included describing the failure.

Output schema (JSON mode)
Top-level envelope for `-o json`:

```json
{
  "requestId": "550e8400-e29b-41d4-a716-446655440000",
  "summary": {
    "total": 3,
    "online": 1,
    "stale": 1,
    "unreachable": 1
  },
  "instances": [
    /* array of instance descriptors (see below) */
  ],
  "elapsedMs": 12
}
```

Instance descriptor (list entry)
```json
{
  "instanceId": "550e8400-e29b-41d4-a716-446655440000",
  "pid": 12345,
  "listenAddr": "127.0.0.1:54321",
  "project": "/home/alice/my-repo",
  "brokkctlVersion": "1.0.0",
  "startedAt": 1690000000000,
  "lastSeenMs": 1690000050000,
  "platform": "linux",
  "listenProtocol": "http",
  "status": "online",
  "stale": false,
  "probe": {
    "reachable": true,
    "serverVersion": "1.0.0",
    "latencyMs": 5
  },
  "error": null
}
```

Field notes:
- `status` (string): one of:
  - `"online"` — lastSeen within TTL and probe (when performed) succeeded or not performed.
  - `"stale"` — lastSeen older than TTL. When `--all` is used this is returned; otherwise stale entries are omitted.
  - `"unreachable"` — entry exists in registry but a probe to `listenAddr` failed (network error, auth error, etc.).
- `stale` (boolean): convenience boolean equivalent to `status == "stale"`.
- `probe` (optional object): results of a lightweight reachability probe (present only when probes are performed). Includes `reachable` (bool), `serverVersion`, and `latencyMs`.
- `error` (object|null): present when `status == "unreachable"` or when a probe returns an error. Follows canonical Error object shape (code/message/details).

Example `probe` failure/error (embedded in `error`)
```json
"error": {
  "code": "TRANSPORT_ERROR",
  "message": "connection refused",
  "details": {
    "attemptedAddr": "127.0.0.1:54321",
    "cause": "ECONNREFUSED"
  }
}
```

Behavior details for `--all`
- When `--all` is supplied:
  - Return all registry files, regardless of age.
  - Mark entries older than TTL with `status: "stale"` and `stale: true`.
  - Optionally perform reachability probes (see flags) to detect `unreachable` entries and populate `probe` and `error` fields. Probing increases latency and may require credentials if endpoints are secured; probes should only be performed when necessary (e.g., when `--probe` is explicitly passed, or when `--all --format json --verbose`).
  - `unreachable` entries are included only in `--all` view (they may also appear as `stale` if age exceeds TTL).

Examples

1) Zero instances (no registry files / nothing discovered)

Command:
- `brokkctl instances list -o json`

Output:
```json
{
  "requestId": "generated-or-empty",
  "summary": { "total": 0, "online": 0, "stale": 0, "unreachable": 0 },
  "instances": [],
  "elapsedMs": 5
}
```

Behavior: The CLI should return exit code `0` (success) and a helpful `text` message when not in JSON mode, e.g., "No Brokk instances found. Run Brokk or use --instance to target an instance."

2) Single online instance (normal case)

Command:
- `brokkctl instances list -o json`

Output:
```json
{
  "requestId": "550e8400-e29b-41d4-a716-446655440000",
  "summary": { "total": 1, "online": 1, "stale": 0, "unreachable": 0 },
  "instances": [
    {
      "instanceId": "550e8400-e29b-41d4-a716-446655440000",
      "pid": 12345,
      "listenAddr": "127.0.0.1:54321",
      "project": "/home/alice/my-repo",
      "brokkctlVersion": "1.0.0",
      "startedAt": 1690000000000,
      "lastSeenMs": 1690000050000,
      "platform": "linux",
      "listenProtocol": "http",
      "status": "online",
      "stale": false,
      "probe": { "reachable": true, "serverVersion": "1.0.0", "latencyMs": 3 },
      "error": null
    }
  ],
  "elapsedMs": 8
}
```

Behavior: Exit code `0`. In `text` mode, show a compact table with the instanceId, pid, listenAddr, project, and version.

3) Many instances with mixed states (example using `--all`)

Command:
- `brokkctl instances list --all -o json --ttl 30000`

Output:
```json
{
  "requestId": "550e8400-e29b-41d4-a716-446655440001",
  "summary": { "total": 3, "online": 1, "stale": 1, "unreachable": 1 },
  "instances": [
    {
      "instanceId": "a1111111-1111-1111-1111-111111111111",
      "pid": 11111,
      "listenAddr": "127.0.0.1:54000",
      "project": "/home/alice/project-a",
      "brokkctlVersion": "1.1.0",
      "startedAt": 1690000000000,
      "lastSeenMs": 1690001050000,
      "platform": "linux",
      "listenProtocol": "http",
      "status": "online",
      "stale": false,
      "probe": { "reachable": true, "serverVersion": "1.1.0", "latencyMs": 4 },
      "error": null
    },
    {
      "instanceId": "b2222222-2222-2222-2222-222222222222",
      "pid": 22222,
      "listenAddr": "/tmp/brokk-22222.sock",
      "project": "/home/alice/project-b",
      "brokkctlVersion": "1.0.0",
      "startedAt": 1689990000000,
      "lastSeenMs": 1689999000000,
      "platform": "linux",
      "listenProtocol": "unix",
      "status": "stale",
      "stale": true,
      "probe": { "reachable": false, "latencyMs": 0 },
      "error": null
    },
    {
      "instanceId": "c3333333-3333-3333-3333-333333333333",
      "pid": null,
      "listenAddr": "127.0.0.1:54200",
      "project": null,
      "brokkctlVersion": "1.0.0",
      "startedAt": 1689990000000,
      "lastSeenMs": 1689995000000,
      "platform": "linux",
      "listenProtocol": "http",
      "status": "unreachable",
      "stale": true,
      "probe": { "reachable": false, "latencyMs": 0 },
      "error": {
        "code": "TRANSPORT_ERROR",
        "message": "connection refused",
        "details": { "attemptedAddr": "127.0.0.1:54200", "cause": "ECONNREFUSED" }
      }
    }
  ],
  "elapsedMs": 60
}
```

Notes on the example:
- The first entry is current/online (within TTL).
- The second entry is stale by age but probing did not produce a connection error (possibly the instance is paused or removed).
- The third entry is stale and probing produced a transport-level error; it's marked `unreachable` and includes an `error` detailing the probe failure.
- Clients should treat `status == "online"` as suitable for immediate operations. `stale` entries may be re-probed or pruned. `unreachable` entries indicate registry residue and can be pruned using `instances prune` (if appropriate permissions exist).

Implementation hints
- Keep `instances list` cheap by default: avoid network probes unless explicitly requested or when running `--all` with `--probe`.
- Make `--all` the only flag that includes stale/unreachable entries; otherwise scripts will observe only currently-considered-live instances.
- Provide `instances prune` to remove stale/unreachable registry files (guarded by ownership checks).
- Always include `lastSeenMs` in output so callers can apply their own TTL logic.

## Projects commands — specification

This section specifies `brokkctl projects list` and `brokkctl projects open`. These commands allow automation to enumerate projects known to running instances and to request that an instance open a particular project/workspace.

Goals
- Provide a machine-friendly enumeration of projects visible across discovered instances.
- Support deterministic selectors for opening a project by `path` or `projectId`.
- Represent duplicates (same project open in multiple instances) explicitly so callers can choose a target.
- Return structured, actionable errors for common failure modes (not found, already open, permission denied, transport/auth errors).

Common command semantics
- Projects are identified by:
  - `path` — canonical absolute filesystem path (string). Clients SHOULD normalize paths to a platform-canonical form before comparing.
  - `projectId` — an opaque identifier assigned by an instance for an opened project (string). Not all instances may expose `projectId`; when absent `path` is the canonical identity.
- `projects list` aggregates declarations from discovered instances. Each instance's report includes the workspace `path` and optional `projectId` and metadata (name, lastOpenedMs).
- `projects open` requests that an instance open the project at a given `path` (or `projectId` for local-to-instance operations). The command targets one or more instances depending on `--instance`/`--all` flags.

Global flags (inherit from top-level)
- `--format json|text`, `--instance <selector>`, `--all`, `--timeout`, `--request-id`, `--auth-token`, etc.
- `projects open` specific flags:
  - `--path <abs-path>` — open project at specified absolute path (preferred).
  - `--project-id <id>` — instance-local project id (used for intra-instance actions).
  - `--create-if-missing` — if the instance does not have the project discovered, attempt to create/open it (may fail with permission or not-supported).
  - `--wait <ms>` — wait for the instance to report the project as opened (useful for automation needing synchronous completion).

Note: `projects open` semantics differ when targeting multiple instances. Opening the same path across multiple instances is allowed and is treated as independent operations per instance. Use `--all` to fan-out.

projects list — behavior & schema
- Default: return projects aggregated from non-stale instances only. Use `--all` to include entries from stale instances.
- For each discovered instance, the instance should report zero or more project descriptors:
  - `projectId` (string|null): instance-local identifier for the project.
  - `path` (string): absolute canonical path to the project root.
  - `name` (string|null): optional project display name (e.g., repository name).
  - `lastOpenedMs` (number|null): epoch ms when instance last reported this project active/open.
  - `status` (string): one of `open` or `closed` from the instance's perspective.
  - `readOnly` (boolean, optional): whether the instance opened the project in read-only mode.
  - `instanceId` (string): instance where this descriptor came from.

Output envelope (JSON mode) — `projects list` top-level
```json
{
  "requestId": "uuid",
  "summary": { "totalProjects": 3, "uniquePaths": 2 },
  "projects": [
    {
      "path": "/home/alice/project-a",
      "name": "project-a",
      "instances": [
        {
          "instanceId": "a111...",
          "projectId": "p-123",
          "status": "open",
          "lastOpenedMs": 1690001050000,
          "readOnly": false
        },
        {
          "instanceId": "b222...",
          "projectId": "p-555",
          "status": "open",
          "lastOpenedMs": 1690001000000,
          "readOnly": true
        }
      ]
    },
    {
      "path": "/home/alice/project-b",
      "name": "project-b",
      "instances": [
        {
          "instanceId": "c333...",
          "projectId": null,
          "status": "closed",
          "lastOpenedMs": null
        }
      ]
    }
  ],
  "elapsedMs": 25
}
```

Notes:
- `projects` is grouped by canonical `path` (the aggregation key). This allows callers to see duplicates across instances. For projects reported with different paths that normalize to the same canonical path, implementations SHOULD merge entries under the normalized path.
- `summary.uniquePaths` counts canonical distinct paths after normalization.
- If an instance reports a project but does not expose `projectId`, `projectId` should be null and callers should use `--instance` + `--path` to target that instance for `projects open`/other operations.

Example: `projects list` zero projects
```json
{
  "requestId": "gen",
  "summary": { "totalProjects": 0, "uniquePaths": 0 },
  "projects": [],
  "elapsedMs": 4
}
```

projects open — behavior & per-instance results
- `projects open` is an operational command that may be targeted at:
  - A single instance via `--instance <selector>` (recommended).
  - Multiple instances via `--all` (fan-out; use with care).
  - Auto-selected instance via `--auto-select`.
- The client may pass `--path` or `--project-id`. If both are supplied, `--project-id` is interpreted as an instance-local id and `--path` must match the located project on that instance or the command should error with `INVALID_ARGS`.
- If `--create-if-missing` is set, the instance may attempt to create or register an absent project. If unsupported, the instance returns `PROTOCOL_UNSUPPORTED_FEATURE` or `NOT_FOUND` depending on semantics.

Per-instance result container (projects open)
```json
{
  "instanceId": "a111...",
  "status": "ok",
  "data": {
    "projectId": "p-123",
    "path": "/home/alice/project-a",
    "openedAtMs": 1690002000000
  },
  "error": null,
  "elapsedMs": 120
}
```

Error cases and canonical error codes
- `NOT_FOUND` — requested path/projectId not found on the targeted instance.
  - Example details: `{ "attemptedPath": "...", "reason": "not-in-workspace" }`
- `ALREADY_OPEN` — instance already has the project open in an incompatible mode (e.g., same project open read-only but client requested write).
  - Example details: `{ "currentMode": "read-only", "requestedMode": "read-write" }`
- `PERMISSION_DENIED` — instance was denied access to open path (filesystem permission issues, sandboxing).
  - Example details: `{ "attemptedPath": "...", "osError": "EACCES" }`
- `PROTOCOL_UNSUPPORTED_FEATURE` — instance does not support `--create-if-missing` or other optional features.
- `TRANSPORT_ERROR` / `UNAUTHORIZED` — as in overall transport/security failures.

Fan-out aggregation for `projects open`
- When `--all` is used, return the aggregate envelope described earlier: `summary` with requested/succeeded/failed and `results` array of per-instance containers. Mixed outcomes map to `PARTIAL_SUCCESS` exit code `4`.

Examples

1) Successful open on a single instance
Command:
- `brokkctl projects open --instance a111... --path /home/alice/project-a -o json`

Output:
```json
{
  "requestId": "req-1",
  "results": [
    {
      "instanceId": "a111...",
      "status": "ok",
      "data": {
        "projectId": "p-123",
        "path": "/home/alice/project-a",
        "openedAtMs": 1690002000000
      },
      "error": null,
      "elapsedMs": 120
    }
  ],
  "summary": { "requested": 1, "succeeded": 1, "failed": 0 }
}
```

2) Project not found on targeted instance
Command:
- `brokkctl projects open --instance a111... --path /not/exist -o json`

Output:
```json
{
  "requestId": "req-2",
  "results": [
    {
      "instanceId": "a111...",
      "status": "error",
      "data": null,
      "error": {
        "code": "NOT_FOUND",
        "message": "Path '/not/exist' not found or not a supported workspace root on instance 'a111...'",
        "details": { "attemptedPath": "/not/exist" }
      },
      "elapsedMs": 30
    }
  ],
  "summary": { "requested": 1, "succeeded": 0, "failed": 1 }
}
```

3) Already open (incompatible mode)
Command:
- `brokkctl projects open --instance b222... --path /home/alice/project-a --create-if-missing -o json`

Output:
```json
{
  "requestId": "req-3",
  "results": [
    {
      "instanceId": "b222...",
      "status": "error",
      "data": null,
      "error": {
        "code": "ALREADY_OPEN",
        "message": "Project is already open in read-only mode on this instance.",
        "details": { "currentMode": "read-only", "requestedMode": "read-write" }
      },
      "elapsedMs": 5
    }
  ],
  "summary": { "requested": 1, "succeeded": 0, "failed": 1 }
}
```

4) Fan-out open with mixed outcomes
Command:
- `brokkctl projects open --all --path /shared/repo -o json --best-effort`

Output:
```json
{
  "requestId": "req-4",
  "summary": { "requested": 3, "succeeded": 2, "failed": 1 },
  "results": [
    {
      "instanceId": "a111...",
      "status": "ok",
      "data": { "projectId": "p-123", "path": "/shared/repo", "openedAtMs": 1690003000000 },
      "error": null
    },
    {
      "instanceId": "b222...",
      "status": "ok",
      "data": { "projectId": "p-555", "path": "/shared/repo", "openedAtMs": 1690003000100 },
      "error": null
    },
    {
      "instanceId": "c333...",
      "status": "error",
      "data": null,
      "error": { "code": "PERMISSION_DENIED", "message": "Access denied to '/shared/repo'", "details": {} }
    }
  ],
  "elapsedMs": 410
}
```

Implementation guidance (projects)
- Normalize paths for grouping and comparison. Prefer platform-canonical absolute paths.
- Provide both `path`-first and `projectId`-first flows. When `projectId` is provided, require `--instance` to resolve it deterministically (projectId is instance-local).
- When aggregating `projects list`, group results by normalized `path`. Include the per-instance descriptors under `instances`.
- For `projects open`, prefer single-instance targeting for predictable behavior in scripts. If `--all` is used, make failure policy explicit via `--fail-fast`/`--best-effort`.
- Report clear, machine-friendly error codes (NOT_FOUND, ALREADY_OPEN, PERMISSION_DENIED) and include useful `details` for automation.

## Appendix: Example Shapes

Instance descriptor (discovery)
```json
{
  "instanceId": "550e8400-e29b-41d4-a716-446655440000",
  "pid": 12345,
  "listenAddr": "127.0.0.1:54321",
  "project": "/home/alice/my-repo",
  "brokkctlVersion": "1.0.0",
  "lastSeenMs": 1690000000000
}
```

Fan-out response (uses canonical envelopes)
```json
{
  "requestId": "550e8400-e29b-41d4-a716-446655440000",
  "summary": { "requested": 3, "succeeded": 2, "failed": 1 },
  "results": [
    { "instanceId":"a","status":"ok","data":{ /* ... */ }, "error": null },
    { "instanceId":"b","status":"ok","data":{ /* ... */ }, "error": null },
    { "instanceId":"c","status":"error","data":null,"error":{"code":"BUSY","message":"instance is busy"} }
  ]
}
```

---
This specification is intentionally concise and implementation-agnostic while providing actionable rules for discovery, negotiation, compatibility, error handling, and output shapes. The next phase is a reference implementation that selects a discovery mechanism and wires the `ctl-info` endpoint on the Brokk side and a minimal `brokkctl` client that implements the negotiation and JSON-first output.
