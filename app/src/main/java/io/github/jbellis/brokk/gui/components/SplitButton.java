package io.github.jbellis.brokk.gui.components;

import static io.github.jbellis.brokk.gui.components.SplitButton.SplitButtonUI.ARROW_WIDTH;

import com.formdev.flatlaf.ui.FlatButtonUI;
import java.awt.*;
import java.awt.event.MouseEvent;
import java.util.function.Supplier;
import javax.swing.*;
import javax.swing.plaf.basic.BasicButtonListener;
import org.jetbrains.annotations.Nullable;

public class SplitButton extends JButton {
    private @Nullable Supplier<JPopupMenu> menuSupplier;
    private @Nullable JPopupMenu popupMenu; // Cache the menu

    public SplitButton(String text) {
        super(text);
        applyStyling();
        // updateUI will call setUI with the correct UI delegate.
        // This ensures our custom UI is (re)applied after L&F changes.
        updateUI();
    }

    private void applyStyling() {
        setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
        setFocusable(true);
        setOpaque(false);
        putClientProperty("JButton.buttonType", "borderless");
        setBorder(null);

        // Allow the Look-and-Feel to render rollover effects by keeping the content area filled
        // and enabling rollover support on the button model.
        setContentAreaFilled(true);
        setRolloverEnabled(true);

        Color linkColor = UIManager.getColor("Label.linkForeground");
        if (linkColor == null) {
            linkColor = UIManager.getColor("Label.foreground");
        }
        if (linkColor == null) {
            linkColor = Color.BLUE;
        }
        setForeground(linkColor);
    }

    @Override
    public void updateUI() {
        super.updateUI(); // Allow L&F to set its default UI first (e.g. FlatButtonUI)
        setUI(new SplitButtonUI()); // Then install our custom UI that extends it.
    }

    public void setMenuSupplier(Supplier<JPopupMenu> menuSupplier) {
        this.menuSupplier = menuSupplier;
        this.popupMenu = null; // Invalidate cached menu, it will be regenerated by the supplier
    }

    // Called by SplitButtonUI when the arrow area is clicked
    void showPopupMenuInternal() {
        if (!isEnabled()) {
            return;
        }
        if (menuSupplier != null) {
            // Create menu on demand if not already created or if supplier changed
            var currentMenu = menuSupplier.get();
            if (currentMenu != null) {
                popupMenu = currentMenu; // Update cached menu
                popupMenu.show(this, 0, getHeight());
            }
        }
    }

    private boolean inSuperPaint = false; // Managed by SplitButtonUI during paint

    // Called by SplitButtonUI to control margin adjustment during super.paint()
    void setInSuperPaint(boolean inSuperPaint) {
        this.inSuperPaint = inSuperPaint;
    }

    @Override
    public Insets getMargin() {
        Insets originalMargin = super.getMargin();
        if (inSuperPaint) {
            Insets m = (Insets)
                    (super.getMargin() == null
                            ? new Insets(0, 0, 0, 0)
                            : super.getMargin().clone());

            // FIXME o3 and I weren't able to figure out how to center
            // the text correctly, this is the best we came up with
            // (combined with the extra space in the " Ask" label)
            m.left += 2;
            m.right += ARROW_WIDTH;
            return m;
        }
        return originalMargin;
    }

    @Override
    public void setPreferredSize(Dimension preferredSize) {
        super.setPreferredSize(preferredSize);
    }

    @Override
    public void setMinimumSize(Dimension minimumSize) {
        super.setMinimumSize(minimumSize);
    }

    @Override
    public void setMaximumSize(Dimension maximumSize) {
        super.setMaximumSize(maximumSize);
    }

    public static class SplitButtonUI extends FlatButtonUI {

        public static final int ARROW_WIDTH = 18; // Width of the arrow area
        private static final int ARROW_ICON_SIZE = 8; // Size of the triangle

        public SplitButtonUI() {
            super(false); // Pass false for the 'shared' parameter
        }

        @Override
        public void installUI(JComponent c) {
            super.installUI(c);
            // Potentially set defaults here if needed, e.g., c.setOpaque(false) or specific margins.
        }

        @Override
        public void uninstallUI(JComponent c) {
            super.uninstallUI(c);
        }

        @Override
        protected BasicButtonListener createButtonListener(AbstractButton b) {
            return new BasicButtonListener(b) {
                @Override
                public void mousePressed(MouseEvent e) {
                    var button = (AbstractButton) e.getComponent();
                    if (!button.isEnabled()) {
                        return;
                    }

                    if (isClickOnArrowArea(button, e.getX())) {
                        if (button instanceof SplitButton sb) {
                            sb.showPopupMenuInternal();
                        }
                        // Prevent the button model from being armed, which would trigger action listeners
                        button.getModel().setArmed(false);
                        button.getModel().setPressed(false);
                        e.consume(); // Consume event to stop further processing
                    } else {
                        super.mousePressed(e);
                    }
                }

                @Override
                public void mouseReleased(MouseEvent e) {
                    var button = (AbstractButton) e.getComponent();
                    if (!button.isEnabled()) {
                        return;
                    }
                    // If the click was on the arrow, the event was consumed,
                    // and model state was managed in mousePressed.
                    // Otherwise, standard behavior.
                    if (!isClickOnArrowArea(button, e.getX())) {
                        super.mouseReleased(e);
                    } else {
                        // Ensure model is not in a state to fire from an arrow click release
                        button.getModel().setArmed(false);
                        button.getModel().setPressed(false);
                        e.consume();
                    }
                }

                private boolean isClickOnArrowArea(AbstractButton button, int x) {
                    return x >= button.getWidth() - ARROW_WIDTH;
                }
            };
        }

        @Override
        public void paint(Graphics g, JComponent c) {
            var sb = (SplitButton) c;

            sb.setInSuperPaint(true);
            super.paint(g, c); // Paint the main button part using FlatButtonUI, which will use adjusted margins
            sb.setInSuperPaint(false);

            // The isBorderPainted() check was problematic with FlatLaf as it might be false
            // even if a border is painted by the L&F.
            // Only check if the button is enabled for painting the arrow.
            if (!sb.isEnabled()) {
                return;
            }

            var g2 = (Graphics2D) g.create();
            g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

            int width = c.getWidth();
            int height = c.getHeight();

            // Draw separator line
            var separatorColor = UIManager.getColor("SplitPane.dividerFocusColor");
            if (separatorColor == null) {
                separatorColor = UIManager.getColor("Button.shadow"); // Fallback
                if (separatorColor == null) {
                    separatorColor = Color.GRAY; // Ultimate fallback
                }
            }
            g2.setColor(separatorColor);
            g2.drawLine(width - ARROW_WIDTH, 2, width - ARROW_WIDTH, height - 3); // Small margin

            // Draw arrow triangle
            var arrowColor = UIManager.getColor("Button.foreground");
            if (arrowColor == null) {
                arrowColor = sb.getForeground(); // Fallback
                if (arrowColor == null) {
                    arrowColor = Color.BLACK; // Ultimate fallback
                }
            }
            g2.setColor(arrowColor);
            int triangleMargin = (ARROW_WIDTH - ARROW_ICON_SIZE) / 2;
            int[] xPoints = {width - ARROW_WIDTH + triangleMargin, width - triangleMargin, width - ARROW_WIDTH / 2};
            int[] yPoints = {
                height / 2 - ARROW_ICON_SIZE / 3, height / 2 - ARROW_ICON_SIZE / 3, height / 2 + ARROW_ICON_SIZE * 2 / 3
            };
            g2.fillPolygon(xPoints, yPoints, 3);

            g2.dispose();
        }

        @Override
        public Dimension getPreferredSize(JComponent c) {
            Dimension d = super.getPreferredSize(c);
            d.width += ARROW_WIDTH;
            return d;
        }

        @Override
        public Dimension getMinimumSize(JComponent c) {
            Dimension d = super.getMinimumSize(c);
            d.width += ARROW_WIDTH;
            return d;
        }

        @Override
        public Dimension getMaximumSize(JComponent c) {
            // The maximum size is the preferred size, which is calculated by the super call
            // and already includes the arrow width.
            return super.getMaximumSize(c);
        }
    }
}
